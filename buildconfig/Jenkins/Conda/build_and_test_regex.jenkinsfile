// Pipeline file for building and running an arbitrary set of system tests and/or unit tests.

// conda-build can't copy a local source if the conda-bld directory is also part of the source.
// Checkout to a subdirectory to avoid this.
CHECKOUT_DIR = 'source'
CISCRIPT_DIR = "${CHECKOUT_DIR}/buildconfig/Jenkins/Conda"

pipeline {
    agent none
    options { checkoutToSubdirectory(CHECKOUT_DIR) }
    parameters {
        booleanParam(name: 'TEST_LINUX', defaultValue: false, description: 'If True, the specified tests will run on Linux')
        booleanParam(name: 'TEST_WINDOWS', defaultValue: false, description: 'If True, the specified tests will run on Windows')
        booleanParam(name: 'TEST_MACOS', defaultValue: false, description: 'If True, the specified tests will run on MacOS')

        booleanParam(name: 'RUN_UNIT_TESTS', defaultValue: false, description: 'If True, the unit tests will be run')
        string(name: 'UNIT_TEST_REGEX', defaultValue: '', description: '''Regex-style selection of tests to run. E.g:
            "SumInQTest|TransformKiKfTest" for two specific tests.
            "Reflectometry|SANS" to run all tests containing the word "Reflectometry" or "SANS".
            Using "ctest -R TEST_REGEX" locally is recommended to check your regex before submitting the job.''')

        booleanParam(name: 'RUN_SYSTEM_TESTS', defaultValue: false, description: 'If True, the system tests will be run')
        string(name: 'SYSTEM_TEST_REGEX', defaultValue: '', description: '''Regex-style selection of tests to run. E.g:
            "FlipperEfficiencyPolarisedTest|FlipperEfficiencyUnpolarisedTest" for two specific tests.
            "Flipper|Polarizer" to run all tests containing the word "Flipper" or "Polarizer".
            Using "./build/systemtest -R TEST_REGEX" locally is recommended to check your regex before submitting the job.''')

        booleanParam(name: 'RUN_DOC_TESTS', defaultValue: false, description: 'If True, run the documentation tests')
    }
    environment {
        WIN_BASH = "C:\\Program Files\\git\\bin\\bash.exe"
        GIT_COMMITTER_NAME = "${GITHUB_USER_NAME}"
        GIT_COMMITTER_EMAIL = "${GITHUB_USER_EMAIL}"
    }

    stages {
        stage('Store git commit') {
          agent { label 'linux-64-regex' }
          steps {
            script {
              env.GIT_SHA = GIT_COMMIT
            }
          }
        }
        stage('Generate git tag') {
          agent { label 'linux-64-regex' }
          steps {
            checkoutSource("${GIT_SHA}")
            script {
              env.GIT_TAG = generate_git_tag()
            }
            echo "${env.GIT_TAG}"
          }
        }
        stage('Build and Test') {
            parallel {
                stage('Build and Test: Linux') {
                    when {
                        beforeAgent true
                        beforeOptions true
                        expression { env.TEST_LINUX == 'true' }
                    }
                    agent { label 'linux-64-regex' }
                    options { timestamps () }
                    steps {
                        checkoutSource("${GIT_SHA}")
                        build_and_test('linux-64')
                    }
                }
                stage('Build and Test: Windows') {
                    when {
                        beforeAgent true
                        beforeOptions true
                        expression { env.TEST_WINDOWS == 'true' }
                    }
                    agent { label 'win-64' }
                    options { timestamps () }
                    steps {
                        checkoutSource("${GIT_SHA}")
                        build_and_test('win-64')
                    }
                }
                stage('Build and Test: macOS') {
                    when {
                        beforeAgent true
                        beforeOptions true
                        expression { env.TEST_MACOS == 'true' }
                    }
                    agent { label 'osx-64' }
                    options { timestamps () }
                    steps {
                        checkoutSource("${GIT_SHA}")
                        build_and_test('osx-64')
                    }
                }
            }
        }
    }
}

def build_and_test(platform) {
    buildscript_path = "${CISCRIPT_DIR}/conda-buildscript"
    args = " --clean-external-projects"
    args += " --disable-unittests"
    args += " --enable-systemtests"
    args += " --systemtest-regex \"${SYSTEM_TEST_REGEX}\""
    args += " --clean-build"
    cmake_preset = "${platform}-ci"
    sh "${buildscript_path} ${WORKSPACE}/${CHECKOUT_DIR} ${cmake_preset} ${args}"
}

def generate_git_tag() {
    git_tag = ""
    versionscript_path = "${CISCRIPT_DIR}/generate-version-number"
    if(isUnix()) {
        git_tag = sh(script: "${versionscript_path}", returnStdout: true).trim()
    } else {
        workspace_unix_style = toUnixStylePath("${WORKSPACE}")
        // @ suppresses the inclusion of the command itself in the output
        // https://www.jenkins.io/doc/pipeline/steps/workflow-durable-task-step/#bat-windows-batch-script
        git_tag = bat(script: "@\"${WIN_BASH}\" -ex -c \"${versionscript_path}\"", returnStdout: true).trim()
    }
    return git_tag
}

def checkoutSource(sha) {
  dir(CHECKOUT_DIR) {
    checkout scm: [
      $class: 'GitSCM',
      branches: [[name: sha]],
      extensions: [
        [$class: 'CheckoutOption', timeout: 20],
        [$class: 'CleanCheckout', deleteUntrackedNestedRepositories: true],
        pruneTags(true)
      ]
    ]
  }
}
